In our setup, we follow a branching model aligned with our CI/CD environments.
Developers work on feature/* branches â€” Jenkins only builds, tests, and runs SonarQube and Trivy scans.
Once merged to develop, Jenkins builds the Docker image, pushes it to ECR, updates the Helm chart, and ArgoCD automatically syncs it to our staging EKS environment.
After testing, code is merged to main, which triggers the same pipeline but deploys to production.

This way, our deployment is completely automated, environment-specific, and follows GitOps principles through ArgoCD



order
cart
checkout
payment

each microservice is having different codebase
for each and evry microservice there is seperate github repository.
each microservice developed by different team
or different set of developers.
each microservice is hvaing there own repo ,own build process ,own deployment process its going all individually.
for each and every repository we have one dockerfile and jenkinsfile 
